// Generated by CoffeeScript 1.6.3
(function() {
  var CoffeeScript, Compiler, Nodes, Optimiser, Parser, Preprocessor, cscodegen, escodegen, escodegenFormat, formatParserError, guess_expr_type, pkg, typecheck, _ref;

  formatParserError = require('./helpers').formatParserError;

  Nodes = require('./nodes');

  Preprocessor = require('./preprocessor').Preprocessor;

  Parser = require('./parser');

  Optimiser = require('./optimiser').Optimiser;

  Compiler = require('./compiler').Compiler;

  cscodegen = (function() {
    try {
      return require('cscodegen');
    } catch (_error) {}
  })();

  escodegen = (function() {
    try {
      return require('escodegen');
    } catch (_error) {}
  })();

  pkg = require('./../package.json');

  escodegenFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };

  guess_expr_type = function(expr) {
    if ((typeof expr.data) === 'number') {
      return 'Number';
    } else if ((typeof expr.data) === 'string') {
      return 'String';
    } else {
      return 'Any';
    }
  };

  typecheck = function(cs_ast, scope) {
    var ScopeNode, assigned_type, assignee, expression, infered_type, registered_type, symbol, _i, _len, _ref, _ref1, _ref2;
    if (scope == null) {
      scope = null;
    }
    ScopeNode = (function() {
      function ScopeNode(parent) {
        this.parent = parent != null ? parent : null;
        this._nodes = [];
        this.defs = {};
      }

      ScopeNode.prototype.setType = function(symbol, type) {
        return this.defs[symbol] = type;
      };

      ScopeNode.prototype.getType = function(symbol) {
        return this.defs[symbol];
      };

      ScopeNode.prototype.addNode = function(node) {
        return this._nodes.push(node);
      };

      ScopeNode.prototype.getSymbolContainedScope = function(symbol) {};

      return ScopeNode;

    })();
    if (scope == null) {
      scope = new ScopeNode;
    }
    console.log(cs_ast.body.statements);
    _ref = cs_ast.body.statements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], assignee = _ref1.assignee, expression = _ref1.expression;
      if (!((assignee != null) && (expression != null))) {
        continue;
      }
      symbol = assignee.data;
      if (scope.getType(symbol) != null) {
        infered_type = guess_expr_type(expression);
        registered_type = scope.getType(symbol);
        if (!(registered_type === infered_type || registered_type === 'Any')) {
          throw new Error("'" + symbol + "' is expected to " + registered_type + " indeed " + infered_type);
        }
      }
      assigned_type = (_ref2 = assignee.annotation) != null ? _ref2.type : void 0;
      if (assigned_type) {
        infered_type = guess_expr_type(expression);
        if (assigned_type === 'Any') {
          scope.setType(symbol, 'Any');
        } else if (assigned_type === infered_type) {
          scope.setType(symbol, assignee.annotation.type);
        } else {
          throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + " indeed " + infered_type);
        }
      } else {
        scope.setType(symbol, 'Any');
      }
    }
    return console.log(scope);
  };

  CoffeeScript = {
    CoffeeScript: CoffeeScript,
    Compiler: Compiler,
    Optimiser: Optimiser,
    Parser: Parser,
    Preprocessor: Preprocessor,
    Nodes: Nodes,
    VERSION: pkg.version,
    parse: function(coffee, options) {
      var e, parsed, preprocessed;
      if (options == null) {
        options = {};
      }
      try {
        preprocessed = Preprocessor.process(coffee, {
          literate: options.literate
        });
        parsed = Parser.parse(preprocessed, {
          raw: options.raw,
          inputSource: options.inputSource
        });
        typecheck(parsed);
        if (options.optimise) {
          return Optimiser.optimise(parsed);
        } else {
          return parsed;
        }
      } catch (_error) {
        e = _error;
        if (!(e instanceof Parser.SyntaxError)) {
          throw e;
        }
        throw new Error(formatParserError(preprocessed, e));
      }
    },
    compile: function(csAst, options) {
      return (Compiler.compile(csAst, options)).toBasicObject();
    },
    cs: function(csAst, options) {},
    jsWithSourceMap: function(jsAst, name, options) {
      var targetName, _ref;
      if (name == null) {
        name = 'unknown';
      }
      if (options == null) {
        options = {};
      }
      if (escodegen == null) {
        throw new Error('escodegen not found: run `npm install escodegen`');
      }
      if (!{}.hasOwnProperty.call(jsAst, 'type')) {
        jsAst = jsAst.toBasicObject();
      }
      targetName = options.sourceMapFile || (options.sourceMap && (options.output.match(/^.*[\\\/]([^\\\/]+)$/))[1]);
      return escodegen.generate(jsAst, {
        comment: !options.compact,
        sourceMapWithCode: true,
        sourceMap: name,
        file: targetName || 'unknown',
        format: options.compact ? escodegen.FORMAT_MINIFY : (_ref = options.format) != null ? _ref : escodegenFormat
      });
    },
    js: function(jsAst, options) {
      return (this.jsWithSourceMap(jsAst, null, options)).code;
    },
    sourceMap: function(jsAst, name, options) {
      return (this.jsWithSourceMap(jsAst, name, options)).map;
    },
    cs2js: function(input, options) {
      var csAST, jsAST;
      if (options == null) {
        options = {};
      }
      if (options.optimise == null) {
        options.optimise = true;
      }
      csAST = CoffeeScript.parse(input, options);
      jsAST = CoffeeScript.compile(csAST, {
        bare: options.bare
      });
      return CoffeeScript.js(jsAST, {
        compact: options.compact || options.minify
      });
    }
  };

  module.exports = CoffeeScript;

  if (((_ref = require.extensions) != null ? _ref['.node'] : void 0) != null) {
    CoffeeScript.register = function() {
      return require('./register');
    };
  }

}).call(this);
