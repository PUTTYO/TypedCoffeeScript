// Generated by CoffeeScript 1.6.3
(function() {
  var CoffeeScript, Compiler, Nodes, Optimiser, Parser, Preprocessor, ScopeNode, cscodegen, escodegen, escodegenFormat, formatParserError, guess_expr_type, pkg, typecheck, _ref, _typecheck;

  formatParserError = require('./helpers').formatParserError;

  Nodes = require('./nodes');

  Preprocessor = require('./preprocessor').Preprocessor;

  Parser = require('./parser');

  Optimiser = require('./optimiser').Optimiser;

  Compiler = require('./compiler').Compiler;

  cscodegen = (function() {
    try {
      return require('cscodegen');
    } catch (_error) {}
  })();

  escodegen = (function() {
    try {
      return require('escodegen');
    } catch (_error) {}
  })();

  pkg = require('./../package.json');

  escodegenFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };

  guess_expr_type = function(expr) {
    if ((typeof expr.data) === 'number') {
      return 'Number';
    } else if ((typeof expr.data) === 'string') {
      return 'String';
    } else if ((typeof expr.data) === 'boolean') {
      return 'Boolean';
    } else if ((expr.parameters != null) && (expr.body != null)) {
      return 'Function';
    } else {
      return 'Any';
    }
  };

  ScopeNode = (function() {
    function ScopeNode() {
      this.name = '';
      this.nodes = [];
      this.defs = {};
      this.parent = null;
    }

    ScopeNode.prototype.setType = function(symbol, type) {
      return this.defs[symbol] = type;
    };

    ScopeNode.prototype.getType = function(symbol) {
      return this.defs[symbol];
    };

    ScopeNode.prototype.getScopedType = function(symbol) {
      var _ref;
      return this.getType(symbol) || ((_ref = this.parent) != null ? _ref.getScopedType(symbol) : void 0) || void 0;
    };

    ScopeNode.dump = function(node, prefix) {
      var key, n, val, _i, _len, _ref, _ref1, _results;
      if (prefix == null) {
        prefix = '';
      }
      console.log(prefix + node.name);
      _ref = node.defs;
      for (key in _ref) {
        val = _ref[key];
        console.log(prefix, ' +', key, '::', val);
      }
      _ref1 = node.nodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n = _ref1[_i];
        _results.push(ScopeNode.dump(n, prefix + '  '));
      }
      return _results;
    };

    return ScopeNode;

  })();

  typecheck = function(cs_ast) {
    var root;
    if (!cs_ast.body) {
      return;
    }
    console.log(cs_ast.body.statements);
    root = new ScopeNode;
    root.name = 'root';
    _typecheck(cs_ast.body.statements, root);
    return ScopeNode.dump(root);
  };

  _typecheck = function(statements, scope) {
    var assigned_type, assignee, body, expression, fnode, infered_type, name, node, registered_type, statement, symbol, _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = statements.length; _i < _len; _i++) {
      statement = statements[_i];
      if ((statement.nameAssignee != null) && (statement.ctor != null)) {
        body = statement.body, name = statement.name;
        node = new ScopeNode;
        node.name = name.data;
        node.parent = scope;
        scope.nodes.push(node);
        _typecheck(body.statements, node);
      }
      if ((statement.assignee != null) && (statement.expression != null)) {
        assignee = statement.assignee, expression = statement.expression;
        symbol = assignee.data;
        registered_type = scope.getScopedType(symbol);
        infered_type = guess_expr_type(expression);
        assigned_type = (_ref = assignee.annotation) != null ? _ref.type : void 0;
        if ((registered_type != null) && (assigned_type != null)) {
          throw new Error('double bind', symbol);
        }
        if (registered_type != null) {
          if (!(registered_type === infered_type || registered_type === 'Any')) {
            throw new Error("'" + symbol + "' is expected to " + registered_type + " indeed " + infered_type);
          }
          continue;
        }
        if (assigned_type) {
          if (assigned_type === 'Any') {
            _results.push(scope.setType(symbol, 'Any'));
          } else if (assigned_type === infered_type) {
            scope.setType(symbol, assignee.annotation.type);
            if (infered_type === 'Function') {
              fnode = new ScopeNode;
              fnode.name = symbol;
              fnode.parent = scope;
              scope.nodes.push(fnode);
              _results.push(_typecheck(expression.body.statements, fnode));
            } else {
              _results.push(void 0);
            }
          } else {
            throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + " indeed " + infered_type);
          }
        } else {
          scope.setType(symbol, infered_type);
          if (infered_type === 'Function') {
            fnode = new ScopeNode;
            fnode.name = symbol;
            fnode.parent = scope;
            scope.nodes.push(fnode);
            _results.push(_typecheck(expression.body.statements, fnode));
          } else {
            _results.push(void 0);
          }
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  CoffeeScript = {
    CoffeeScript: CoffeeScript,
    Compiler: Compiler,
    Optimiser: Optimiser,
    Parser: Parser,
    Preprocessor: Preprocessor,
    Nodes: Nodes,
    VERSION: pkg.version,
    parse: function(coffee, options) {
      var e, parsed, preprocessed;
      if (options == null) {
        options = {};
      }
      try {
        preprocessed = Preprocessor.process(coffee, {
          literate: options.literate
        });
        parsed = Parser.parse(preprocessed, {
          raw: options.raw,
          inputSource: options.inputSource
        });
        typecheck(parsed);
        if (options.optimise) {
          return Optimiser.optimise(parsed);
        } else {
          return parsed;
        }
      } catch (_error) {
        e = _error;
        if (!(e instanceof Parser.SyntaxError)) {
          throw e;
        }
        throw new Error(formatParserError(preprocessed, e));
      }
    },
    compile: function(csAst, options) {
      return (Compiler.compile(csAst, options)).toBasicObject();
    },
    cs: function(csAst, options) {},
    jsWithSourceMap: function(jsAst, name, options) {
      var targetName, _ref;
      if (name == null) {
        name = 'unknown';
      }
      if (options == null) {
        options = {};
      }
      if (escodegen == null) {
        throw new Error('escodegen not found: run `npm install escodegen`');
      }
      if (!{}.hasOwnProperty.call(jsAst, 'type')) {
        jsAst = jsAst.toBasicObject();
      }
      targetName = options.sourceMapFile || (options.sourceMap && (options.output.match(/^.*[\\\/]([^\\\/]+)$/))[1]);
      return escodegen.generate(jsAst, {
        comment: !options.compact,
        sourceMapWithCode: true,
        sourceMap: name,
        file: targetName || 'unknown',
        format: options.compact ? escodegen.FORMAT_MINIFY : (_ref = options.format) != null ? _ref : escodegenFormat
      });
    },
    js: function(jsAst, options) {
      return (this.jsWithSourceMap(jsAst, null, options)).code;
    },
    sourceMap: function(jsAst, name, options) {
      return (this.jsWithSourceMap(jsAst, name, options)).map;
    },
    cs2js: function(input, options) {
      var csAST, jsAST;
      if (options == null) {
        options = {};
      }
      if (options.optimise == null) {
        options.optimise = true;
      }
      csAST = CoffeeScript.parse(input, options);
      jsAST = CoffeeScript.compile(csAST, {
        bare: options.bare
      });
      return CoffeeScript.js(jsAST, {
        compact: options.compact || options.minify
      });
    }
  };

  module.exports = CoffeeScript;

  if (((_ref = require.extensions) != null ? _ref['.node'] : void 0) != null) {
    CoffeeScript.register = function() {
      return require('./register');
    };
  }

}).call(this);
