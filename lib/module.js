// Generated by CoffeeScript 1.6.3
(function() {
  var CoffeeScript, Compiler, Nodes, Optimiser, Parser, Preprocessor, cscodegen, decide_expr_type, escodegen, escodegenFormat, formatParserError, pkg, scope, typecheck, _ref;

  formatParserError = require('./helpers').formatParserError;

  Nodes = require('./nodes');

  Preprocessor = require('./preprocessor').Preprocessor;

  Parser = require('./parser');

  Optimiser = require('./optimiser').Optimiser;

  Compiler = require('./compiler').Compiler;

  cscodegen = (function() {
    try {
      return require('cscodegen');
    } catch (_error) {}
  })();

  escodegen = (function() {
    try {
      return require('escodegen');
    } catch (_error) {}
  })();

  pkg = require('./../package.json');

  escodegenFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };

  decide_expr_type = function(expr) {
    if ((typeof expr.data) === 'number') {
      return 'number';
    } else if ((typeof expr.data) === 'string') {
      return 'string';
    } else {
      return 'any';
    }
  };

  scope = {};

  typecheck = function(cs_ast) {
    var assignee, expression, _i, _len, _ref, _ref1, _ref2, _ref3;
    console.log(cs_ast.body.statements);
    _ref = cs_ast.body.statements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], assignee = _ref1.assignee, expression = _ref1.expression;
      if (!((assignee != null) && (expression != null))) {
        continue;
      }
      if (((_ref2 = assignee.annotation) != null ? (_ref3 = _ref2.type) != null ? _ref3.toLowerCase() : void 0 : void 0) !== decide_expr_type(expression)) {
        throw new Error("'" + assignee.data + "' is expected to " + assignee.annotation.type + " indeed " + (decide_expr_type(expression)));
      }
      scope[assignee.data] = assignee.annotation.type;
    }
    return console.log(scope);
  };

  CoffeeScript = {
    CoffeeScript: CoffeeScript,
    Compiler: Compiler,
    Optimiser: Optimiser,
    Parser: Parser,
    Preprocessor: Preprocessor,
    Nodes: Nodes,
    VERSION: pkg.version,
    parse: function(coffee, options) {
      var e, parsed, preprocessed;
      if (options == null) {
        options = {};
      }
      try {
        preprocessed = Preprocessor.process(coffee, {
          literate: options.literate
        });
        parsed = Parser.parse(preprocessed, {
          raw: options.raw,
          inputSource: options.inputSource
        });
        typecheck(parsed);
        if (options.optimise) {
          return Optimiser.optimise(parsed);
        } else {
          return parsed;
        }
      } catch (_error) {
        e = _error;
        if (!(e instanceof Parser.SyntaxError)) {
          throw e;
        }
        throw new Error(formatParserError(preprocessed, e));
      }
    },
    compile: function(csAst, options) {
      return (Compiler.compile(csAst, options)).toBasicObject();
    },
    cs: function(csAst, options) {},
    jsWithSourceMap: function(jsAst, name, options) {
      var targetName, _ref;
      if (name == null) {
        name = 'unknown';
      }
      if (options == null) {
        options = {};
      }
      if (escodegen == null) {
        throw new Error('escodegen not found: run `npm install escodegen`');
      }
      if (!{}.hasOwnProperty.call(jsAst, 'type')) {
        jsAst = jsAst.toBasicObject();
      }
      targetName = options.sourceMapFile || (options.sourceMap && (options.output.match(/^.*[\\\/]([^\\\/]+)$/))[1]);
      return escodegen.generate(jsAst, {
        comment: !options.compact,
        sourceMapWithCode: true,
        sourceMap: name,
        file: targetName || 'unknown',
        format: options.compact ? escodegen.FORMAT_MINIFY : (_ref = options.format) != null ? _ref : escodegenFormat
      });
    },
    js: function(jsAst, options) {
      return (this.jsWithSourceMap(jsAst, null, options)).code;
    },
    sourceMap: function(jsAst, name, options) {
      return (this.jsWithSourceMap(jsAst, name, options)).map;
    },
    cs2js: function(input, options) {
      var csAST, jsAST;
      if (options == null) {
        options = {};
      }
      if (options.optimise == null) {
        options.optimise = true;
      }
      csAST = CoffeeScript.parse(input, options);
      jsAST = CoffeeScript.compile(csAST, {
        bare: options.bare
      });
      return CoffeeScript.js(jsAST, {
        compact: options.compact || options.minify
      });
    }
  };

  module.exports = CoffeeScript;

  if (((_ref = require.extensions) != null ? _ref['.node'] : void 0) != null) {
    CoffeeScript.register = function() {
      return require('./register');
    };
  }

}).call(this);
