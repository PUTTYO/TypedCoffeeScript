[ { assignee: { members: [Object] },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { data: 'Nodes', annotation: '' },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { members: [Object] },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { data: 'Parser', annotation: '' },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { members: [Object] },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { members: [Object] },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { data: 'cscodegen', annotation: '' },
    expression: 
     { body: [Object],
       catchAssignee: null,
       catchBody: null,
       finallyBody: null } },
  { assignee: { data: 'escodegen', annotation: '' },
    expression: 
     { body: [Object],
       catchAssignee: null,
       catchBody: null,
       finallyBody: null } },
  { assignee: { data: 'pkg', annotation: '' },
    expression: { function: [Object], arguments: [Object] } },
  { assignee: { data: 'escodegenFormat', annotation: '' },
    expression: { members: [Object] } },
  { assignee: { data: 'guess_expr_type', annotation: '' },
    expression: { parameters: [Object], body: [Object] } },
  { assignee: { data: 'typecheck', annotation: '' },
    expression: { parameters: [Object], body: [Object] } },
  { assignee: { data: 'CoffeeScript', annotation: '' },
    expression: { members: [Object] } },
  { assignee: { expression: [Object], memberName: 'exports', raw: NaN },
    expression: { data: 'CoffeeScript', annotation: '' } },
  { condition: { expression: [Object] },
    consequent: { statements: [Object] },
    alternate: null } ]
{}
// Generated by CoffeeScript 2.0.0-beta8-dev
var CoffeeScript, Compiler, cscodegen, escodegen, escodegenFormat, formatParserError, guess_expr_type, Nodes, Optimiser, Parser, pkg, Preprocessor, typecheck;
formatParserError = require('./helpers').formatParserError;
Nodes = require('./nodes');
Preprocessor = require('./preprocessor').Preprocessor;
Parser = require('./parser');
Optimiser = require('./optimiser').Optimiser;
Compiler = require('./compiler').Compiler;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$) {
    return;
  }
}.call(this);
pkg = require('./../package.json');
escodegenFormat = {
  indent: {
    style: '  ',
    base: 0
  },
  renumber: true,
  hexadecimal: true,
  quotes: 'auto',
  parentheses: false
};
guess_expr_type = function (expr) {
  if (typeof expr.data === 'number') {
    return 'number';
  } else if (typeof expr.data === 'string') {
    return 'string';
  } else {
    return 'any';
  }
};
typecheck = function (cs_ast, scope) {
  var assigned_type, assignee, cache$, expression, infered_type, registered_type, symbol;
  if (null == scope)
    scope = {};
  console.log(cs_ast.body.statements);
  for (var i$ = 0, length$ = cs_ast.body.statements.length; i$ < length$; ++i$) {
    {
      cache$ = cs_ast.body.statements[i$];
      assignee = cache$.assignee;
      expression = cache$.expression;
    }
    if (!('undefined' !== typeof assignee && null != assignee && ('undefined' !== typeof expression && null != expression)))
      continue;
    symbol = assignee.data;
    if (null != scope[symbol]) {
      infered_type = guess_expr_type(expression);
      registered_type = scope[symbol].toLowerCase();
      if (!(registered_type === infered_type || registered_type === 'any'))
        throw new Error("'" + symbol + "' is expected to " + registered_type + ' indeed ' + infered_type);
    }
    assigned_type = null != assignee.annotation ? assignee.annotation.type : void 0;
    if (assigned_type) {
      infered_type = guess_expr_type(expression);
      if (assigned_type.toLowerCase() === infered_type) {
        scope[symbol] = assignee.annotation.type;
      } else {
        throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + ' indeed ' + infered_type);
      }
    }
  }
  return console.log(scope);
};
CoffeeScript = {
  CoffeeScript: CoffeeScript,
  Compiler: Compiler,
  Optimiser: Optimiser,
  Parser: Parser,
  Preprocessor: Preprocessor,
  Nodes: Nodes,
  VERSION: pkg.version,
  parse: function (coffee, options) {
    var e, parsed, preprocessed;
    if (null == options)
      options = {};
    try {
      preprocessed = Preprocessor.process(coffee, { literate: options.literate });
      parsed = Parser.parse(preprocessed, {
        raw: options.raw,
        inputSource: options.inputSource
      });
      typecheck(parsed);
      if (options.optimise) {
        return Optimiser.optimise(parsed);
      } else {
        return parsed;
      }
    } catch (e$) {
      e = e$;
      if (!(e instanceof Parser.SyntaxError))
        throw e;
      throw new Error(formatParserError(preprocessed, e));
    }
  },
  compile: function (csAst, options) {
    return Compiler.compile(csAst, options).toBasicObject();
  },
  cs: function (csAst, options) {
  },
  jsWithSourceMap: function (jsAst, name, options) {
    var targetName;
    if (null == name)
      name = 'unknown';
    if (null == options)
      options = {};
    if (!(null != escodegen))
      throw new Error('escodegen not found: run `npm install escodegen`');
    if (!{}.hasOwnProperty.call(jsAst, 'type'))
      jsAst = jsAst.toBasicObject();
    targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
    return escodegen.generate(jsAst, {
      comment: !options.compact,
      sourceMapWithCode: true,
      sourceMap: name,
      file: targetName || 'unknown',
      format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat
    });
  },
  js: function (jsAst, options) {
    return this.jsWithSourceMap(jsAst, null, options).code;
  },
  sourceMap: function (jsAst, name, options) {
    return this.jsWithSourceMap(jsAst, name, options).map;
  },
  cs2js: function (input, options) {
    var csAST, jsAST;
    if (null == options)
      options = {};
    if (null != options.optimise)
      options.optimise;
    else
      options.optimise = true;
    csAST = CoffeeScript.parse(input, options);
    jsAST = CoffeeScript.compile(csAST, { bare: options.bare });
    return CoffeeScript.js(jsAST, { compact: options.compact || options.minify });
  }
};
module.exports = CoffeeScript;
if (null != (null != require.extensions ? require.extensions['.node'] : void 0))
  CoffeeScript.register = function () {
    return require('./register');
  };
