// Generated by CoffeeScript 2.0.0-beta8-dev
var _typecheck, CoffeeScript, Compiler, console, cscodegen, escodegen, escodegenFormat, formatParserError, guess_expr_type, Nodes, Optimiser, Parser, pkg, Preprocessor, ScopeNode, typecheck;
formatParserError = require('./helpers').formatParserError;
Nodes = require('./nodes');
Preprocessor = require('./preprocessor').Preprocessor;
Parser = require('./parser');
Optimiser = require('./optimiser').Optimiser;
Compiler = require('./compiler').Compiler;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$) {
    return;
  }
}.call(this);
pkg = require('./../package.json');
escodegenFormat = {
  indent: {
    style: '  ',
    base: 0
  },
  renumber: true,
  hexadecimal: true,
  quotes: 'auto',
  parentheses: false
};
guess_expr_type = function (expr) {
  if (typeof expr.data === 'number') {
    return 'Number';
  } else if (typeof expr.data === 'string') {
    return 'String';
  } else if (typeof expr.data === 'boolean') {
    return 'Boolean';
  } else if (null != expr.parameters && null != expr.body) {
    return 'Function';
  } else {
    return 'Any';
  }
};
console = {
  log: function () {
  }
};
ScopeNode = function () {
  function ScopeNode() {
    this.name = '';
    this.nodes = [];
    this.defs = {};
    this.parent = null;
  }
  ScopeNode.prototype.setType = function (symbol, type) {
    return this.defs[symbol] = type;
  };
  ScopeNode.prototype.getType = function (symbol) {
    return this.defs[symbol];
  };
  ScopeNode.prototype.getScopedType = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getScopedType(symbol) : void 0) || void 0;
  };
  ScopeNode.dump = function (node, prefix) {
    var key, val;
    if (null == prefix)
      prefix = '';
    console.log(prefix + ('[' + node.name + ']'));
    for (key in node.defs) {
      val = node.defs[key];
      console.log(prefix, ' +', key, '::', val);
    }
    return function (accum$) {
      var n;
      for (var i$ = 0, length$ = node.nodes.length; i$ < length$; ++i$) {
        n = node.nodes[i$];
        accum$.push(ScopeNode.dump(n, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  return ScopeNode;
}();
typecheck = function (cs_ast) {
  var root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  console.log(cs_ast.body.statements);
  root = new ScopeNode;
  root.name = 'root';
  _typecheck(cs_ast.body.statements, root);
  return ScopeNode.dump(root);
};
_typecheck = function (statements, scope) {
  return function (accum$) {
    var assigned_type, assignee, body, cache$, cache$1, expression, fnode, infered_type, name, node, registered_type, statement, symbol;
    for (var i$ = 0, length$ = statements.length; i$ < length$; ++i$) {
      statement = statements[i$];
      accum$.push(null != statement.nameAssignee && null != statement.body ? (cache$ = statement, body = cache$.body, name = cache$.name, node = new ScopeNode, node.name = name.data, node.parent = scope, scope.nodes.push(node), _typecheck(body.statements, node)) : null != statement.assignee && null != statement.expression ? (cache$1 = statement, assignee = cache$1.assignee, expression = cache$1.expression, symbol = assignee.data, registered_type = scope.getScopedType(symbol), infered_type = guess_expr_type(expression), assigned_type = null != assignee.annotation ? assignee.annotation.type : void 0, null != registered_type && null != assigned_type ? function () {
        throw new Error('double bind', symbol);
      }() : null != registered_type ? !(registered_type === infered_type || registered_type === 'Any') ? function () {
        throw new Error("'" + symbol + "' is expected to " + registered_type + ' indeed ' + infered_type);
      }() : void 0 : assigned_type ? assigned_type === 'Any' ? scope.setType(symbol, 'Any') : assigned_type === infered_type ? (scope.setType(symbol, assignee.annotation.type), infered_type === 'Function' ? (fnode = new ScopeNode, fnode.name = symbol, fnode.parent = scope, scope.nodes.push(fnode), _typecheck(expression.body.statements, fnode)) : void 0) : function () {
        throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + ' indeed ' + infered_type);
      }() : (scope.setType(symbol, 'Any'), infered_type === 'Function' && null != (null != expression.body ? expression.body.statements : void 0) ? (fnode = new ScopeNode, fnode.name = symbol, fnode.parent = scope, scope.nodes.push(fnode), _typecheck(expression.body.statements, fnode)) : void 0)) : void 0);
    }
    return accum$;
  }.call(this, []);
};
CoffeeScript = {
  CoffeeScript: CoffeeScript,
  Compiler: Compiler,
  Optimiser: Optimiser,
  Parser: Parser,
  Preprocessor: Preprocessor,
  Nodes: Nodes,
  VERSION: pkg.version,
  parse: function (coffee, options) {
    var e, parsed, preprocessed;
    if (null == options)
      options = {};
    try {
      preprocessed = Preprocessor.process(coffee, { literate: options.literate });
      parsed = Parser.parse(preprocessed, {
        raw: options.raw,
        inputSource: options.inputSource
      });
      typecheck(parsed);
      if (options.optimise) {
        return Optimiser.optimise(parsed);
      } else {
        return parsed;
      }
    } catch (e$) {
      e = e$;
      if (!(e instanceof Parser.SyntaxError))
        throw e;
      throw new Error(formatParserError(preprocessed, e));
    }
  },
  compile: function (csAst, options) {
    return Compiler.compile(csAst, options).toBasicObject();
  },
  cs: function (csAst, options) {
  },
  jsWithSourceMap: function (jsAst, name, options) {
    var targetName;
    if (null == name)
      name = 'unknown';
    if (null == options)
      options = {};
    if (!(null != escodegen))
      throw new Error('escodegen not found: run `npm install escodegen`');
    if (!{}.hasOwnProperty.call(jsAst, 'type'))
      jsAst = jsAst.toBasicObject();
    targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
    return escodegen.generate(jsAst, {
      comment: !options.compact,
      sourceMapWithCode: true,
      sourceMap: name,
      file: targetName || 'unknown',
      format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat
    });
  },
  js: function (jsAst, options) {
    return this.jsWithSourceMap(jsAst, null, options).code;
  },
  sourceMap: function (jsAst, name, options) {
    return this.jsWithSourceMap(jsAst, name, options).map;
  },
  cs2js: function (input, options) {
    var csAST, jsAST;
    if (null == options)
      options = {};
    if (null != options.optimise)
      options.optimise;
    else
      options.optimise = true;
    csAST = CoffeeScript.parse(input, options);
    jsAST = CoffeeScript.compile(csAST, { bare: options.bare });
    return CoffeeScript.js(jsAST, { compact: options.compact || options.minify });
  }
};
module.exports = CoffeeScript;
if (null != (null != require.extensions ? require.extensions['.node'] : void 0))
  CoffeeScript.register = function () {
    return require('./register');
  };
